// Thu added: Prisma Schema 
// File description: Database schema for Gather application including these models:
//    User, 
//    Recipe, 
//    FavoriteRecipe, 
//    Ingredient, 
//    Category, 
//    Notification,
//    Friendship,
//    Comment,
//    Rating,


// ==================== PRISMA SCHEMA ====================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["typedSql", "postgresqlExtensions"] 
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//
// ==================== USER ====================
//
model User {
  id        Int      @id @default(autoincrement()) // Primary Key
  firstname String
  lastname  String
  username  String   @unique
  email     String   @unique
  password  String
  avatarId  String?  @default("melon") // User avatar preset ID (matches DEFAULT_AVATAR_ID)
  createdAt DateTime @default(now())

  // One-to-Many relationship: One User can have 0 to many Recipes
  recipes         Recipe[]
  favoriteRecipes FavoriteRecipe[] // Many-to-many link with Recipe
  favoriteAPIRecipes FavoriteAPIRecipe[]
  notifications   Notification[]
  comments Comment[] // One-to-Many relationship: One User can have many Comments // Added 11/11
  ratings Rating[] // One user can have many ratings // Added 11/13

  // Self-relations for friendships
  sentRequests     Friendship[] @relation("Requester")
  receivedRequests Friendship[] @relation("Addressee")

  // Conversations
  conversationsAsUser1 Conversation[] @relation("User1Conversations")
  conversationsAsUser2 Conversation[] @relation("User2Conversations")
  messages             Message[]
}

//
// ==================== RECIPE ====================
//
model Recipe {
  recipeId     Int      @id @default(autoincrement()) // Primary Key
  userId       Int // Foreign Key referencing User
  recipeName   String
  description  String?
  photoUrl     String? // Store recipe photo path // AnN added
  instructions String? // Cooking steps on 10/30 // AnN added
  videoUrl     String? // YouTube video link on 10/30 // AnN added
  createdAt    DateTime @default(now())

  // Relationship to User (Many Recipes belong to one User)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  recipeIngredients RecipeIngredient[]
  recipeCategories  RecipeCategory[]
  FavoriteRecipe    FavoriteRecipe[]
  comments Comment[] // One-to-Many relationship: One Recipe can have many Comments 
  ratings Rating[] // One recipe can have many ratings 
}

//
// ==================== FAVORITE RECIPE ====================
// (Junction table for Many-to-Many between User and Recipe)
//
model FavoriteRecipe {
  userId   Int
  recipeId Int

  // Relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipe Recipe @relation(fields: [recipeId], references: [recipeId], onDelete: Cascade)

  // Composite Primary Key
  @@id([userId, recipeId])
}

//
// ==================== INGREDIENT ====================
//
model Ingredient {
  ingredientId   Int    @id @default(autoincrement())
  ingredientName String @unique

  // Relations
  recipeIngredients RecipeIngredient[]
}

//
// ==================== RECIPE INGREDIENT ====================
// (Junction table for Many-to-Many between Recipe and Ingredient)
//
model RecipeIngredient {
  recipeId     Int
  ingredientId Int
  quantity     String

  // Relations
  recipe     Recipe     @relation(fields: [recipeId], references: [recipeId], onDelete: Cascade)
  ingredient Ingredient @relation(fields: [ingredientId], references: [ingredientId], onDelete: Cascade)

  @@id([recipeId, ingredientId])
}

//
// ==================== CATEGORY ====================
//
model Category {
  categoryId   Int    @id @default(autoincrement())
  categoryName String @unique

  // Relations
  recipeCategories RecipeCategory[]
}

//
// ==================== RECIPE CATEGORY ====================
// (Junction table for Many-to-Many between Recipe and Category)
//
model RecipeCategory {
  recipeId   Int
  categoryId Int

  // Relations
  recipe   Recipe   @relation(fields: [recipeId], references: [recipeId], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [categoryId], onDelete: Cascade)

  @@id([recipeId, categoryId])
}

//
// ==================== FAVORITE API RECIPE ====================
// 
model FavoriteAPIRecipe {
  userId   Int
  apiId    String // TheMealDB's idMeal

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@id([userId, apiId])
}

//
// ==================== NOTIFICATION ====================
// 
model Notification {
  id              Int      @id @default(autoincrement())
  userId          Int
  relatedUserId   Int?     // The user who triggered the notification (rater, commenter, etc.) // AnN added 11/25
  relatedRecipeId Int?     // The recipe related to the notification // AnN added 11/25
  type            String   // e.g., 'friend_request', 'friend_accept', 'recipe_rating', 'recipe_comment'
  message         String
  isRead          Boolean  @default(false)
  createdAt       DateTime @default(now())

  user            User     @relation(fields: [userId], references: [id])
}

//
// ==================== FRIENDSHIP ====================
// 
model Friendship {
  id           Int      @id @default(autoincrement())
  requesterId  Int
  addresseeId  Int
  status       String   @default("none") // none | pending | accepted | rejected
  createdAt    DateTime @default(now())

  requester    User     @relation("Requester", fields: [requesterId], references: [id])
  addressee    User     @relation("Addressee", fields: [addresseeId], references: [id])

  @@unique([requesterId, addresseeId])
}

//
// ==================== COMMENT ====================
//
model Comment {
  id          Int      @id @default(autoincrement())
  content     String
  createdAt   DateTime @default(now())
  // updatedAt   DateTime @updatedAt  optional field for future use

  // Foreign Keys
  userId      Int     // The User who made the comment  
  recipeId    Int?    // For User-created recipes
  apiId       String? // For API recipes // TheMealDB idMeal

  // Relations
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipe      Recipe? @relation(fields: [recipeId], references: [recipeId], onDelete: Cascade)
}

//
// ==================== RATING ====================
//
model Rating {
  id        Int      @id @default(autoincrement())
  value     Int      // rating score (1â€“5 stars)
  createdAt DateTime @default(now())

  // Foreign keys
  userId   Int
  recipeId Int?      // for user-created recipes
  apiId    String?   // for API recipes

  // Relations
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipe   Recipe?   @relation(fields: [recipeId], references: [recipeId], onDelete: Cascade)

  // Ensure one rating per user per recipe/api recipe
  @@unique([userId, recipeId])
  @@unique([userId, apiId])
}

//
// ==================== CONVERSATION ====================
//
model Conversation {
  id        Int       @id @default(autoincrement())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  user1Id   Int // Store the smaller user ID for consistency
  user2Id   Int // Store the larger  user ID for consistency
  user1     User      @relation("User1Conversations", fields: [user1Id], references: [id])
  user2     User      @relation("User2Conversations", fields: [user2Id], references: [id])

  // One-to-Many relationship: One Conversation can have many Messages
  messages  Message[] 

  @@unique([user1Id, user2Id])
}

//
// ==================== MESSAGE ====================
//
model Message {
  id             Int          @id @default(autoincrement())
  createdAt      DateTime     @default(now())
  content        String

  conversationId Int // Foreign Key referencing Conversation
  senderId       Int // User who sent the message

  conversation   Conversation @relation(fields: [conversationId], references: [id])
  sender         User         @relation(fields: [senderId], references: [id])
}
